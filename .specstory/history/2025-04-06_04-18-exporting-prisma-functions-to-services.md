<!-- Generated by SpecStory -->

# Exporting Prisma Functions to Services (2025-04-06 09:18:59)

_**User**_

Continue doing the same export as much prisma involved funtions as a small utility function to services folder with right directory 

---

_**Assistant**_



---

<details>
            <summary>Searched codebase "findOrderById in services/refund" ‚Ä¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `services/order/create/createOrderRecord.ts` | L14-50 |
| `services/order/create/createOrderStats.ts` | L13-46 |
| `services/order/create/createOrderProductLookup.ts` | L16-51 |
| `services/order/fetch/fetchOrders.ts` | L109-153 |
| `services/order/fetch/fetchOrders.ts` | L14-30 |
| `services/order/fetch/fetchOrders.ts` | L40-69 |
| `services/order/fetch/fetchOrders.ts` | L30-40 |
| `services/order/create/createOrderStats.ts` | L5-13 |
| `services/order/create/createOrderRecord.ts` | L1-14 |
| `services/order/fetch/fetchOrders.ts` | L69-109 |
| `services/order/create/createOrderProductLookup.ts` | L12-16 |
| `services/order/create/createOrderProductLookup.ts` | L5-12 |
| `services/order/create/createOrderItem.ts` | L10-28 |
| `services/order/create/index.ts` | L41-50 |
| `services/order/fetch/fetchOrders.ts` | L1-11 |
| `services/order/create/createOrderItemMetaEntries.ts` | L7-20 |
| `services/order/create/createOrderItemMeta.ts` | L1-6 |
| `services/order/create/createOrderItemMeta.ts` | L11-67 |
| `services/order/create/index.ts` | L16-30 |
| `services/order/create/updateProductStock.ts` | L47-78 |
| `services/order/create/createOrderItemMeta.ts` | L6-11 |
| `services/order/create/createOrderProductLookup.ts` | L1-5 |
| `services/order/create/updateProductStock.ts` | L11-16 |
| `services/order/fetch/index.ts` | L1-1 |
| `services/order/create/createBundledItemMeta.ts` | L7-12 |

</details>

---

<details>
            <summary>Searched codebase "findOrderById in services/refund file" ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

<details>
            <summary>Searched codebase "refund services" ‚Ä¢ **10** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

Read file: services/refund/create/findOrderById.ts

---

Read file: services/refund/index.ts

---

Read file: services/refund/create/index.ts

---

<details>
            <summary>Listed directory services/refund ‚Ä¢ **3** results</summary>
        
| Name |
|-------|
| üìÑ `index.ts` |
| üìÅ `create` |
| üìÅ `fetch` |

</details>

---

<details>
            <summary>Listed directory services/refund/create ‚Ä¢ **2** results</summary>
        
| Name |
|-------|
| üìÑ `index.ts` |
| üìÑ `findOrderById.ts` |

</details>

---

<details>
            <summary>Listed directory services/refund/fetch ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

Now I'll extract utility functions from the refund route and organize them in the services/refund directory following the existing pattern. I'll start by creating new functions in the refund/create directory.

---

```diff
- 
+ interface TransactionClient {
+   wp_wc_orders: {
+     update: Function;
+   };
+ }
+ 
+ /**
+  * Updates an order with rental calculations
+  */
+ export async function updateOrderWithRentalCalculations({
+   tx,
+   orderId,
+   endDateTime,
+   usedDays,
+   rentalPrice,
+   reason,
+   refundType,
+ }: {
+   tx: TransactionClient;
+   orderId: number | string;
+   endDateTime: Date;
+   usedDays: number;
+   rentalPrice: number;
+   reason?: string;
+   refundType?: "partial" | "full";
+ }) {
+   return await tx.wp_wc_orders.update({
+     where: {
+       id: BigInt(orderId),
+     },
+     data: {
+       end_date: endDateTime,
+       used_days: usedDays,
+       rental_price: BigInt(Math.round(rentalPrice)),
+       date_updated_gmt: new Date(),
+       customer_note: reason || null,
+       ...(refundType === "full" ? { status: "wc-refunded" } : {}),
+     },
+   });
+ } 
```

---

```diff
- 
+ /**
+  * Calculates rental price based on used days and discount days
+  */
+ export function calculateRentalPrice({
+   startDateTime,
+   endDateTime,
+   discountDays,
+   baseAmount,
+ }: {
+   startDateTime: Date;
+   endDateTime: Date;
+   discountDays: number;
+   baseAmount: number;
+ }): { usedDays: number; effectiveDays: number; rentalPrice: number } {
+   if (!startDateTime) {
+     throw new Error("Start date is required for rental calculations");
+   }
+ 
+   // Calculate used days as the difference between end_date and start_date
+   const usedDays = Math.ceil(
+     (endDateTime.getTime() - startDateTime.getTime()) / (1000 * 60 * 60 * 24)
+   );
+ 
+   if (usedDays < 0) {
+     throw new Error("End date cannot be earlier than start date");
+   }
+ 
+   // Calculate rental price based on used days and discount days
+   const effectiveDays = Math.max(0, usedDays - discountDays);
+   const rentalPrice = effectiveDays * baseAmount;
+ 
+   return {
+     usedDays,
+     effectiveDays,
+     rentalPrice
+   };
+ } 
```

---

```diff
- 
+ interface TransactionClient {
+   wp_wc_orders: {
+     create: Function;
+   };
+ }
+ 
+ interface OriginalOrder {
+   id: bigint;
+   currency?: string;
+   customer_id?: bigint;
+   start_date?: Date;
+   status?: string;
+ }
+ 
+ /**
+  * Creates a refund order record
+  */
+ export async function createRefundOrder({
+   tx,
+   refundOrderId,
+   originalOrder,
+   totalRefundAmount,
+   endDateTime,
+   usedDays,
+   rentalPrice,
+   reason,
+ }: {
+   tx: TransactionClient;
+   refundOrderId: bigint;
+   originalOrder: OriginalOrder;
+   totalRefundAmount: number;
+   endDateTime: Date;
+   usedDays: number;
+   rentalPrice: number;
+   reason?: string;
+ }) {
+   return await tx.wp_wc_orders.create({
+     data: {
+       id: refundOrderId,
+       status: "wc-completed",
+       currency: originalOrder.currency || "UZS",
+       type: "shop_order_refund",
+       tax_amount: 0,
+       total_amount: -totalRefundAmount,
+       customer_id: originalOrder.customer_id,
+       billing_email: null,
+       date_created_gmt: new Date(),
+       date_updated_gmt: new Date(),
+       parent_order_id: originalOrder.id,
+       payment_method: null,
+       payment_method_title: null,
+       transaction_id: null,
+       ip_address: null,
+       user_agent: null,
+       customer_note: reason || null,
+       start_date: originalOrder.start_date,
+       end_date: endDateTime,
+       used_days: usedDays,
+       rental_price: BigInt(Math.round(rentalPrice)),
+     },
+   });
+ } 
```

---

```diff
- 
+ interface TransactionClient {
+   wp_wc_orders_meta: {
+     createMany: Function;
+   };
+ }
+ 
+ /**
+  * Stores refund metadata
+  */
+ export async function storeRefundMetadata({
+   tx,
+   refundOrderId,
+   totalRefundAmount,
+   refundPayment,
+   reason,
+   refundType,
+ }: {
+   tx: TransactionClient;
+   refundOrderId: bigint;
+   totalRefundAmount: number;
+   refundPayment?: boolean;
+   reason?: string;
+   refundType?: string;
+ }) {
+   return await tx.wp_wc_orders_meta.createMany({
+     data: [
+       {
+         order_id: refundOrderId,
+         meta_key: "_refund_amount",
+         meta_value: totalRefundAmount.toString(),
+       },
+       {
+         order_id: refundOrderId,
+         meta_key: "_refunded_by",
+         meta_value: "1", // Assuming admin user ID 1
+       },
+       {
+         order_id: refundOrderId,
+         meta_key: "_refunded_payment",
+         meta_value: refundPayment ? "1" : "",
+       },
+       {
+         order_id: refundOrderId,
+         meta_key: "_refund_reason",
+         meta_value: reason || "",
+       },
+       {
+         order_id: refundOrderId,
+         meta_key: "_refund_type",
+         meta_value: refundType || "partial",
+       },
+     ],
+   });
+ } 
```

---

```diff
- 
+ interface TransactionClient {
+   wp_wc_order_stats: {
+     create: Function;
+     updateMany: Function;
+   };
+ }
+ 
+ interface RefundItem {
+   quantity: number;
+ }
+ 
+ /**
+  * Creates order stats for a refund
+  */
+ export async function createRefundOrderStats({
+   tx,
+   refundOrderId,
+   orderId,
+   items,
+   totalRefundAmount,
+   customerId,
+   refundType,
+ }: {
+   tx: TransactionClient;
+   refundOrderId: bigint;
+   orderId: number | string;
+   items: RefundItem[];
+   totalRefundAmount: number;
+   customerId: bigint;
+   refundType?: "partial" | "full";
+ }) {
+   try {
+     // Create negative stats entry for the refund
+     await tx.wp_wc_order_stats.create({
+       data: {
+         order_id: refundOrderId,
+         parent_id: BigInt(orderId),
+         date_created: new Date(),
+         date_created_gmt: new Date(),
+         num_items_sold: -items.reduce(
+           (total, item) => total + item.quantity,
+           0
+         ),
+         total_sales: -totalRefundAmount,
+         tax_total: 0,
+         shipping_total: 0,
+         net_total: -totalRefundAmount,
+         returning_customer: null,
+         status: "wc-completed",
+         customer_id: customerId || BigInt(0),
+       },
+     });
+ 
+     // Update original order stats only for full refunds
+     if (refundType === "full") {
+       await tx.wp_wc_order_stats.updateMany({
+         where: { order_id: BigInt(orderId) },
+         data: { status: "wc-refunded" },
+       });
+     }
+ 
+     return true;
+   } catch (error) {
+     console.warn("Order stats update failed, continuing with refund process");
+     return false;
+   }
+ } 
```

---

```diff
- 
+ interface TransactionClient {
+   wp_postmeta: {
+     findFirst: Function;
+     updateMany: Function;
+   };
+   wp_wc_product_meta_lookup: {
+     updateMany: Function;
+   };
+   wp_woocommerce_bundled_items: {
+     findMany: Function;
+   };
+   wp_woocommerce_bundled_itemmeta: {
+     updateMany: Function;
+   };
+   wp_comments: {
+     create: Function;
+   };
+ }
+ 
+ interface StockAdjustment {
+   productId: number;
+   quantity: number;
+ }
+ 
+ /**
+  * Updates product stock levels during refund
+  */
+ export async function updateProductStock({
+   tx,
+   adjustment,
+   orderId,
+ }: {
+   tx: TransactionClient;
+   adjustment: StockAdjustment;
+   orderId: number | string;
+ }) {
+   const { productId, quantity } = adjustment;
+ 
+   try {
+     // Get current stock
+     const stockMeta = await tx.wp_postmeta.findFirst({
+       where: {
+         post_id: BigInt(productId),
+         meta_key: "_stock",
+       },
+     });
+ 
+     if (stockMeta) {
+       const oldStock = parseInt(stockMeta.meta_value || "0") || 0;
+       const newStock = oldStock + quantity;
+ 
+       // Update stock in wp_postmeta
+       await tx.wp_postmeta.updateMany({
+         where: {
+           post_id: BigInt(productId),
+           meta_key: "_stock",
+         },
+         data: {
+           meta_value: newStock.toString(),
+         },
+       });
+ 
+       // Update product meta lookup
+       await tx.wp_wc_product_meta_lookup.updateMany({
+         where: {
+           product_id: BigInt(productId),
+         },
+         data: {
+           stock_quantity: newStock,
+           stock_status: newStock > 0 ? "instock" : "outofstock",
+         },
+       });
+ 
+       // Update bundled item metadata if this product is part of bundles
+       const bundledItems = await tx.wp_woocommerce_bundled_items.findMany({
+         where: {
+           product_id: BigInt(productId),
+         },
+         select: {
+           bundled_item_id: true,
+         },
+       });
+ 
+       if (bundledItems.length > 0) {
+         await tx.wp_woocommerce_bundled_itemmeta.updateMany({
+           where: {
+             bundled_item_id: {
+               in: bundledItems.map((item) => item.bundled_item_id),
+             },
+             meta_key: "max_stock",
+           },
+           data: {
+             meta_value: newStock.toString(),
+           },
+         });
+       }
+ 
+       // Add comment for stock adjustment
+       await tx.wp_comments.create({
+         data: {
+           comment_post_ID: BigInt(orderId),
+           comment_author: "WooCommerce",
+           comment_author_email: "woocommerce@lesa.smarts.uz",
+           comment_author_url: "",
+           comment_author_IP: "",
+           comment_date: new Date(),
+           comment_date_gmt: new Date(),
+           comment_content: `Item #${productId} stock increased from ${oldStock} to ${newStock}.`,
+           comment_karma: 0,
+           comment_approved: "1",
+           comment_agent: "WooCommerce",
+           comment_type: "order_note",
+           comment_parent: BigInt(0),
+           user_id: BigInt(0),
+         },
+       });
+ 
+       return {
+         success: true,
+         oldStock,
+         newStock,
+         productId,
+       };
+     } else {
+       console.warn(
+         `No stock found for product ${productId}, skipping stock adjustment`
+       );
+       return {
+         success: false,
+         reason: "no_stock_found",
+         productId,
+       };
+     }
+   } catch (stockError) {
+     console.error(
+       `Error updating stock for product ${productId}:`,
+       stockError
+     );
+     return {
+       success: false,
+       reason: "error",
+       error: stockError,
+       productId,
+     };
+   }
+ } 
```

---

```diff
    quantity: number;
  }
+ 
+ interface BundledItem {
+   bundled_item_id: number | bigint;
+ }
  
  /**
            where: {
              bundled_item_id: {
-               in: bundledItems.map((item) => item.bundled_item_id),
+               in: bundledItems.map((item: BundledItem) => item.bundled_item_id),
              },
              meta_key: "max_stock",
```

---

```diff
- 
+ interface TransactionClient {
+   wp_comments: {
+     create: Function;
+   };
+ }
+ 
+ /**
+  * Adds a refund comment to the order
+  */
+ export async function addRefundComment({
+   tx,
+   orderId,
+   content,
+   commentType = "order_note",
+ }: {
+   tx: TransactionClient;
+   orderId: number | string;
+   content: string;
+   commentType?: string;
+ }) {
+   return await tx.wp_comments.create({
+     data: {
+       comment_post_ID: BigInt(orderId),
+       comment_author: "WooCommerce",
+       comment_author_email: "woocommerce@lesa.smarts.uz",
+       comment_author_url: "",
+       comment_author_IP: "",
+       comment_date: new Date(),
+       comment_date_gmt: new Date(),
+       comment_content: content,
+       comment_karma: 0,
+       comment_approved: "1",
+       comment_agent: "WooCommerce",
+       comment_type: commentType,
+       comment_parent: BigInt(0),
+       user_id: BigInt(0),
+     },
+   });
+ } 
```

---

```diff
- 
+ interface TransactionClient {
+   wp_posts: {
+     findUnique: Function;
+   };
+   wp_woocommerce_order_items: {
+     create: Function;
+   };
+   wp_woocommerce_order_itemmeta: {
+     createMany: Function;
+   };
+   wp_wc_order_product_lookup: {
+     create: Function;
+   };
+ }
+ 
+ interface RefundItem {
+   itemId: number;
+   productId: number;
+   quantity: number;
+   amount: number;
+ }
+ 
+ interface OriginalOrder {
+   customer_id?: bigint;
+   used_days?: number;
+   currency?: string;
+ }
+ 
+ /**
+  * Creates a refund order item
+  */
+ export async function createRefundOrderItem({
+   tx,
+   refundOrderId,
+   item,
+   originalOrder,
+   discountDays,
+ }: {
+   tx: TransactionClient;
+   refundOrderId: bigint;
+   item: RefundItem;
+   originalOrder: OriginalOrder;
+   discountDays: number;
+ }) {
+   // Get product info
+   const productResult = await tx.wp_posts.findUnique({
+     where: { ID: BigInt(item.productId) },
+     select: { post_title: true },
+   });
+ 
+   const productName = productResult
+     ? productResult.post_title
+     : `Product #${item.productId}`;
+ 
+   // Create refund line item
+   const refundItem = await tx.wp_woocommerce_order_items.create({
+     data: {
+       order_item_name: productName,
+       order_item_type: "line_item",
+       order_id: refundOrderId,
+     },
+   });
+ 
+   // For the refund item, qty and amount should be NEGATIVE
+   const negativeQty = -Math.abs(item.quantity);
+   const negativeAmount = -Math.abs(item.amount);
+ 
+   // Create item meta for the refund item
+   await tx.wp_woocommerce_order_itemmeta.createMany({
+     data: [
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_product_id",
+         meta_value: item.productId.toString(),
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_variation_id",
+         meta_value: "0",
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_qty",
+         meta_value: negativeQty.toString(),
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_tax_class",
+         meta_value: "",
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_line_subtotal",
+         meta_value: negativeAmount.toString(),
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_line_subtotal_tax",
+         meta_value: "0",
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_line_total",
+         meta_value: negativeAmount.toString(),
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_line_tax",
+         meta_value: "0",
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_line_tax_data",
+         meta_value: 'a:2:{s:5:"total";a:0:{}s:8:"subtotal";a:0:{}}',
+       },
+       {
+         order_item_id: refundItem.order_item_id,
+         meta_key: "_refunded_item_id",
+         meta_value: item.itemId.toString(),
+       },
+     ],
+   });
+ 
+   // Add entry to wp_wc_order_product_lookup for the refund
+   await tx.wp_wc_order_product_lookup.create({
+     data: {
+       order_item_id: refundItem.order_item_id,
+       order_id: refundOrderId,
+       product_id: BigInt(item.productId),
+       variation_id: BigInt(0),
+       customer_id: originalOrder.customer_id || BigInt(0),
+       date_created: new Date(),
+       product_qty: negativeQty,
+       product_net_revenue: Number(negativeAmount),
+       product_gross_revenue: Number(negativeAmount),
+       coupon_amount: Number(0),
+       tax_amount: Number(0),
+       shipping_amount: Number(0),
+       shipping_tax_amount: Number(0),
+       used_days: originalOrder.used_days,
+       rental_price: BigInt(
+         Math.round(
+           Math.abs(negativeAmount) *
+             Math.max(0, (originalOrder.used_days || 0) - discountDays)
+         )
+       ),
+     },
+   });
+ 
+   // Mark original item as restocked
+   await tx.wp_woocommerce_order_itemmeta.create({
+     data: {
+       order_item_id: BigInt(item.itemId),
+       meta_key: "_restock_refunded_items",
+       meta_value: item.quantity.toString(), // Positive for restocking
+     },
+   });
+ 
+   return {
+     refundItem,
+     productName,
+     negativeQty,
+     negativeAmount,
+     itemDescription: `${productName} (${item.amount} ${originalOrder.currency})`,
+   };
+ } 
```

---

```diff
    wp_woocommerce_order_itemmeta: {
      createMany: Function;
+     create: Function;
    };
    wp_wc_order_product_lookup: {
```

---

```diff
  // Export refund creation services
  export { findOrderById } from './findOrderById';
+ export { calculateRentalPrice } from './calculateRentalPrice';
+ export { updateOrderWithRentalCalculations } from './updateOrderWithRentalCalculations';
+ export { createRefundOrder } from './createRefundOrder';
+ export { storeRefundMetadata } from './storeRefundMetadata';
+ export { createRefundOrderStats } from './createRefundOrderStats';
+ export { createRefundOrderItem } from './createRefundOrderItem';
+ export { updateProductStock } from './updateProductStock';
+ export { addRefundComment } from './addRefundComment'; 
```

---

I've successfully extracted utility functions from the refund route and organized them in the services/refund directory following the existing pattern. Here's a summary of the created functions:

1. `calculateRentalPrice` - Calculates rental price based on start/end dates and discount days
2. `updateOrderWithRentalCalculations` - Updates order record with rental calculations 
3. `createRefundOrder` - Creates a refund order record
4. `storeRefundMetadata` - Stores metadata for the refund
5. `createRefundOrderStats` - Creates and updates order statistics for refunds
6. `createRefundOrderItem` - Creates refund line items
7. `updateProductStock` - Updates product stock levels during refund
8. `addRefundComment` - Adds comments to the order for tracking refund actions

These functions follow the existing pattern in the codebase where each function accepts a transaction object and other relevant parameters. The functions are properly typed with TypeScript interfaces and include appropriate error handling.

The next step would be to refactor the main refund route to use these utility functions instead of having all the logic directly in the route handler. This would make the code more maintainable and testable.

---

_**User**_

now use those functions 

---

_**Assistant**_



---

```diff
  import { NextResponse } from "next/server";
  import { prisma } from "@/lib/prisma";
- import { findOrderById } from "@/services/refund";
+ import {
+   findOrderById,
+   calculateRentalPrice,
+   updateOrderWithRentalCalculations,
+   createRefundOrder,
+   storeRefundMetadata,
+   createRefundOrderStats,
+   createRefundOrderItem,
+   updateProductStock,
+   addRefundComment
+ } from "@/services/refund";
  
  interface RefundRequest {
          }
  
-         // Calculate used days as the difference between end_date and start_date
+         // Calculate rental price
          const endDateTime = new Date(endDate);
-         const startDateTime = originalOrder.start_date;
- 
-         if (!startDateTime) {
-           throw new Error(
-             "Order start_date is required for rental calculations"
-           );
-         }
- 
-         const usedDays = Math.ceil(
-           (endDateTime.getTime() - startDateTime.getTime()) /
-             (1000 * 60 * 60 * 24)
-         );
- 
-         if (usedDays < 0) {
-           throw new Error("End date cannot be earlier than start date");
-         }
- 
-         // Calculate rental price based on used days and discount days
-         const effectiveDays = Math.max(0, usedDays - discountDays);
-         const rentalPrice = effectiveDays * totalRefundAmount;
+         const rentalCalculation = calculateRentalPrice({
+           startDateTime: originalOrder.start_date as Date,
+           endDateTime,
+           discountDays,
+           baseAmount: totalRefundAmount,
+         });
  
          // Update the original order with rental calculations
-         await tx.wp_wc_orders.update({
-           where: {
-             id: BigInt(orderId),
-           },
-           data: {
-             end_date: endDateTime,
-             used_days: usedDays,
-             rental_price: BigInt(Math.round(rentalPrice)),
-             date_updated_gmt: new Date(),
-             customer_note: reason || null,
-             ...(refundType === "full" ? { status: "wc-refunded" } : {}),
-           },
+         await updateOrderWithRentalCalculations({
+           tx,
+           orderId,
+           endDateTime,
+           usedDays: rentalCalculation.usedDays,
+           rentalPrice: rentalCalculation.rentalPrice,
+           reason,
+           refundType,
          });
  
  
          // Create refund order record
-         await tx.wp_wc_orders.create({
-           data: {
-             id: refundOrderId,
-             status: "wc-completed",
-             currency: originalOrder.currency || "UZS",
-             type: "shop_order_refund",
-             tax_amount: 0,
-             total_amount: -totalRefundAmount,
-             customer_id: originalOrder.customer_id,
-             billing_email: null,
-             date_created_gmt: now,
-             date_updated_gmt: now,
-             parent_order_id: originalOrder.id,
-             payment_method: null,
-             payment_method_title: null,
-             transaction_id: null,
-             ip_address: null,
-             user_agent: null,
-             customer_note: reason || null,
-             start_date: originalOrder.start_date,
-             end_date: endDateTime,
-             used_days: usedDays,
-             rental_price: BigInt(Math.round(rentalPrice)),
-           },
+         await createRefundOrder({
+           tx,
+           refundOrderId,
+           originalOrder,
+           totalRefundAmount,
+           endDateTime,
+           usedDays: rentalCalculation.usedDays,
+           rentalPrice: rentalCalculation.rentalPrice,
+           reason
          });
  
          // Store refund metadata
-         await tx.wp_wc_orders_meta.createMany({
-           data: [
-             {
-               order_id: refundOrderId,
-               meta_key: "_refund_amount",
-               meta_value: totalRefundAmount.toString(),
-             },
-             {
-               order_id: refundOrderId,
-               meta_key: "_refunded_by",
-               meta_value: "1", // Assuming admin user ID 1
-             },
-             {
-               order_id: refundOrderId,
-               meta_key: "_refunded_payment",
-               meta_value: refundPayment ? "1" : "",
-             },
-             {
-               order_id: refundOrderId,
-               meta_key: "_refund_reason",
-               meta_value: reason,
-             },
-             {
-               order_id: refundOrderId,
-               meta_key: "_refund_type",
-               meta_value: refundType,
-             },
-           ],
+         await storeRefundMetadata({
+           tx,
+           refundOrderId,
+           totalRefundAmount,
+           refundPayment,
+           reason,
+           refundType
          });
  
-         // Update order stats if available
-         try {
-           // Create negative stats entry for the refund
-           await tx.wp_wc_order_stats.create({
-             data: {
-               order_id: refundOrderId,
-               parent_id: BigInt(orderId),
-               date_created: now,
-               date_created_gmt: now,
-               num_items_sold: -items.reduce(
-                 (total, item) => total + item.quantity,
-                 0
-               ),
-               total_sales: -totalRefundAmount,
-               tax_total: 0,
-               shipping_total: 0,
-               net_total: -totalRefundAmount,
-               returning_customer: null,
-               status: "wc-completed",
-               customer_id: originalOrder.customer_id || BigInt(0),
-             },
-           });
- 
-           // Update original order stats only for full refunds
-           if (refundType === "full") {
-             await tx.wp_wc_order_stats.updateMany({
-               where: { order_id: BigInt(orderId) },
-               data: { status: "wc-refunded" },
-             });
-           }
-         } catch (error) {
-           // Order stats might not be available in some WooCommerce setups
-           console.warn(
-             "Order stats update failed, continuing with refund process"
-           );
-         }
+         // Update order stats
+         await createRefundOrderStats({
+           tx,
+           refundOrderId,
+           orderId,
+           items,
+           totalRefundAmount,
+           customerId: originalOrder.customer_id as bigint,
+           refundType
+         });
  
          // Process refund items
  
          for (const item of items) {
-           // Get product info
-           const productResult = await tx.wp_posts.findUnique({
-             where: { ID: BigInt(item.productId) },
-             select: { post_title: true },
-           });
- 
-           const productName = productResult
-             ? productResult.post_title
-             : `Product #${item.productId}`;
- 
-           // Create refund line item
-           const refundItem = await tx.wp_woocommerce_order_items.create({
-             data: {
-               order_item_name: productName,
-               order_item_type: "line_item",
-               order_id: refundOrderId,
-             },
-           });
- 
-           // For the refund item, qty and amount should be NEGATIVE
-           const negativeQty = -Math.abs(item.quantity);
-           const negativeAmount = -Math.abs(item.amount);
- 
-           // Create item meta for the refund item
-           await tx.wp_woocommerce_order_itemmeta.createMany({
-             data: [
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_product_id",
-                 meta_value: item.productId.toString(),
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_variation_id",
-                 meta_value: "0",
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_qty",
-                 meta_value: negativeQty.toString(),
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_tax_class",
-                 meta_value: "",
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_line_subtotal",
-                 meta_value: negativeAmount.toString(),
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_line_subtotal_tax",
-                 meta_value: "0",
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_line_total",
-                 meta_value: negativeAmount.toString(),
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_line_tax",
-                 meta_value: "0",
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_line_tax_data",
-                 meta_value: 'a:2:{s:5:"total";a:0:{}s:8:"subtotal";a:0:{}}',
-               },
-               {
-                 order_item_id: refundItem.order_item_id,
-                 meta_key: "_refunded_item_id",
-                 meta_value: item.itemId.toString(),
-               },
-             ],
+           const { itemDescription } = await createRefundOrderItem({
+             tx,
+             refundOrderId,
+             item,
+             originalOrder,
+             discountDays,
            });
  
            // Add to refund note with the positive amount for readability
-           refundNoteItems.push(
-             `${productName} (${item.amount} ${originalOrder.currency})`
-           );
+           refundNoteItems.push(itemDescription);
  
            // Add to stock adjustments if not a bundle or additionally if it's a simple product
              });
            }
- 
-           // Add entry to wp_wc_order_product_lookup for the refund
-           await tx.wp_wc_order_product_lookup.create({
-             data: {
-               order_item_id: refundItem.order_item_id,
-               order_id: refundOrderId,
-               product_id: BigInt(item.productId),
-               variation_id: BigInt(0),
-               customer_id: originalOrder.customer_id || BigInt(0),
-               date_created: now,
-               product_qty: negativeQty,
-               product_net_revenue: Number(negativeAmount),
-               product_gross_revenue: Number(negativeAmount),
-               coupon_amount: Number(0),
-               tax_amount: Number(0),
-               shipping_amount: Number(0),
-               shipping_tax_amount: Number(0),
-               used_days: originalOrder.used_days,
-               rental_price: BigInt(
-                 Math.round(
-                   Math.abs(negativeAmount) *
-                     Math.max(0, (originalOrder.used_days || 0) - discountDays)
-                 )
-               ),
-             },
-           });
- 
-           // Mark original item as restocked
-           await tx.wp_woocommerce_order_itemmeta.create({
-             data: {
-               order_item_id: BigInt(item.itemId),
-               meta_key: "_restock_refunded_items",
-               meta_value: item.quantity.toString(), // Positive for restocking
-             },
-           });
  
            // Process bundled items if this is a bundle
          // Update product stock levels
          for (const adjustment of stockAdjustments) {
-           const { productId, quantity } = adjustment;
- 
-           try {
-             // Get current stock
-             const stockMeta = await tx.wp_postmeta.findFirst({
-               where: {
-                 post_id: BigInt(productId),
-                 meta_key: "_stock",
-               },
-             });
- 
-             if (stockMeta) {
-               const oldStock = parseInt(stockMeta.meta_value || "0") || 0;
-               const newStock = oldStock + quantity;
- 
-               // Update stock in wp_postmeta
-               await tx.wp_postmeta.updateMany({
-                 where: {
-                   post_id: BigInt(productId),
-                   meta_key: "_stock",
-                 },
-                 data: {
-                   meta_value: newStock.toString(),
-                 },
-               });
- 
-               // Update product meta lookup
-               await tx.wp_wc_product_meta_lookup.updateMany({
-                 where: {
-                   product_id: BigInt(productId),
-                 },
-                 data: {
-                   stock_quantity: newStock,
-                   stock_status: newStock > 0 ? "instock" : "outofstock",
-                 },
-               });
- 
-               // Update bundled item metadata if this product is part of bundles
-               const bundledItems =
-                 await tx.wp_woocommerce_bundled_items.findMany({
-                   where: {
-                     product_id: BigInt(productId),
-                   },
-                   select: {
-                     bundled_item_id: true,
-                   },
-                 });
- 
-               if (bundledItems.length > 0) {
-                 await tx.wp_woocommerce_bundled_itemmeta.updateMany({
-                   where: {
-                     bundled_item_id: {
-                       in: bundledItems.map((item) => item.bundled_item_id),
-                     },
-                     meta_key: "max_stock",
-                   },
-                   data: {
-                     meta_value: newStock.toString(),
-                   },
-                 });
-               }
- 
-               // Add comment for stock adjustment
-               await tx.wp_comments.create({
-                 data: {
-                   comment_post_ID: BigInt(orderId),
-                   comment_author: "WooCommerce",
-                   comment_author_email: "woocommerce@lesa.smarts.uz",
-                   comment_author_url: "",
-                   comment_author_IP: "",
-                   comment_date: now,
-                   comment_date_gmt: now,
-                   comment_content: `Item #${productId} stock increased from ${oldStock} to ${newStock}.`,
-                   comment_karma: 0,
-                   comment_approved: "1",
-                   comment_agent: "WooCommerce",
-                   comment_type: "order_note",
-                   comment_parent: BigInt(0),
-                   user_id: BigInt(0),
-                 },
-               });
-             } else {
-               console.warn(
-                 `No stock found for product ${productId}, skipping stock adjustment`
-               );
-             }
-           } catch (stockError) {
-             console.error(
-               `Error updating stock for product ${productId}:`,
-               stockError
-             );
-             // Continue with other stock adjustments
-           }
+           await updateProductStock({
+             tx,
+             adjustment,
+             orderId
+           });
          }
  
          }
  
-         await tx.wp_comments.create({
-           data: {
-             comment_post_ID: BigInt(orderId),
-             comment_author: "WooCommerce",
-             comment_author_email: "woocommerce@lesa.smarts.uz",
-             comment_author_url: "",
-             comment_author_IP: "",
-             comment_date: now,
-             comment_date_gmt: now,
-             comment_content: refundNoteContent,
-             comment_karma: 0,
-             comment_approved: "1",
-             comment_agent: "WooCommerce",
-             comment_type: "order_note",
-             comment_parent: BigInt(0),
-             user_id: BigInt(0),
-           },
+         await addRefundComment({
+           tx,
+           orderId,
+           content: refundNoteContent
          });
  
          // Add status change note only for full refunds
          if (refundType === "full") {
-           await tx.wp_comments.create({
-             data: {
-               comment_post_ID: BigInt(orderId),
-               comment_author: "WooCommerce",
-               comment_author_email: "woocommerce@lesa.smarts.uz",
-               comment_author_url: "",
-               comment_author_IP: "",
-               comment_date: now,
-               comment_date_gmt: now,
-               comment_content: `Order status changed from ${currentStatus.replace(
+           await addRefundComment({
+             tx,
+             orderId,
+             content: `Order status changed from ${currentStatus.replace(
                "wc-",
                ""
-               )} to Refunded.`,
-               comment_karma: 0,
-               comment_approved: "1",
-               comment_agent: "WooCommerce",
-               comment_type: "order_note",
-               comment_parent: BigInt(0),
-               user_id: BigInt(0),
-             },
+             )} to Refunded.`
            });
          } else {
-           await tx.wp_comments.create({
-             data: {
-               comment_post_ID: BigInt(orderId),
-               comment_author: "WooCommerce",
-               comment_author_email: "woocommerce@lesa.smarts.uz",
-               comment_author_url: "",
-               comment_author_IP: "",
-               comment_date: now,
-               comment_date_gmt: now,
-               comment_content: `Partial refund processed (${totalRefundAmount} ${originalOrder.currency}).`,
-               comment_karma: 0,
-               comment_approved: "1",
-               comment_agent: "WooCommerce",
-               comment_type: "order_note",
-               comment_parent: BigInt(0),
-               user_id: BigInt(0),
-             },
+           await addRefundComment({
+             tx,
+             orderId,
+             content: `Partial refund processed (${totalRefundAmount} ${originalOrder.currency}).`
            });
          }
```

---

```diff
  
          for (const item of items) {
-           const { itemDescription } = await createRefundOrderItem({
+           const { refundItem, itemDescription } = await createRefundOrderItem({
              tx,
              refundOrderId,
```

---

I've refactored the refund route to use the utility functions we extracted from the original code. This makes the route handler much more maintainable and easier to test. Now each part of the refund process is modularized into separate functions that can be used independently.

The key improvements in the refactored code include:

1. Better organization with separate concerns in isolated functions
2. Improved reusability of database operations
3. Easier testability of individual components
4. Cleaner, more readable route handler code
5. Consistent error handling and validation

Each function now handles a specific part of the refund process:
- `calculateRentalPrice` - Calculates the rental price based on dates and discount days
- `updateOrderWithRentalCalculations` - Updates the original order with calculated values
- `createRefundOrder` - Creates the refund order record
- `storeRefundMetadata` - Stores metadata for the refund
- `createRefundOrderStats` - Creates statistics for the refund
- `createRefundOrderItem` - Creates refund line items
- `updateProductStock` - Updates product stock levels
- `addRefundComment` - Adds comments to the order

The bundled items processing could be further refactored into a separate utility function in the future to complete the modularization.

---

_**User**_

do the same with selected code

---

_**Assistant**_



---



---

