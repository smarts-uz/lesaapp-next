<!-- Generated by SpecStory -->

# Code Analysis and Refund Fix (2025-04-05 12:11:37)

_**User**_

@schema.prisma @4.sql  analyze the code & fix refund make it proper

---

_**Assistant**_



---

Let me analyze the refund implementation and provide fixes:

---

<details>
            <summary>Searched codebase "issues with refund implementation" â€¢ **19** results</summary>
        
| File | Lines |
|------|-------|
| `types/pos.ts` | L141-156 |
| `types/pos.ts` | L164-176 |
| `lib/woocommerce/utils.ts` | L41-55 |
| `components/dashboard/refund-dialog.tsx` | L224-301 |
| `types/pos.ts` | L156-164 |
| `lib/woocommerce/utils.ts` | L55-82 |
| `components/dashboard/refund-dialog.tsx` | L46-97 |
| `components/dashboard/refund-dialog.tsx` | L174-224 |
| `components/dashboard/refund-history-cell.tsx` | L18-76 |
| `components/dashboard/refund-dialog.tsx` | L301-329 |
| `components/dashboard/refund-dialog.tsx` | L620-665 |
| `.specstory/history/2025-04-02_14-17-woocommerce-database-query-troubleshooting.md` | L133-170 |
| `components/dashboard/refund-dialog.tsx` | L483-525 |
| `components/dashboard/refund-dialog.tsx` | L1-46 |
| `components/pos/refund-button.tsx` | L1-22 |
| `app/dashboard/orders/page.tsx` | L535-574 |
| `components/dashboard/refund-dialog.tsx` | L378-420 |
| `components/dashboard/refund-dialog.tsx` | L571-620 |
| `app/api/refund/route.ts` | L1-1 |

</details>

---

Read file: app/api/refund/route.ts

---

After reviewing the code, I've identified several issues that need to be fixed in the refund implementation:

---

```diff
    reason?: string;
    refundPayment?: boolean;
+   refundType?: "partial" | "full";
  }
  
    try {
      const body = await request.json() as RefundRequest;
-     const { orderId, items, reason = '', refundPayment = false } = body;
+     const { orderId, items, reason = '', refundPayment = false, refundType = 'partial' } = body;
  
      if (!orderId) {
      }
  
-     // Calculate total refund amount
-     const totalRefundAmount = items.reduce((total, item) => total + item.amount, 0);
+     // Validate quantities and amounts
+     for (const item of items) {
+       if (item.quantity <= 0) {
+         return NextResponse.json({ error: "Item quantities must be positive" }, { status: 400 });
+       }
+       if (item.amount <= 0) {
+         return NextResponse.json({ error: "Item amounts must be positive" }, { status: 400 });
+       }
+     }
+ 
+     // Calculate total refund amount - ensure it's a valid decimal
+     const totalRefundAmount = parseFloat(
+       items.reduce((total, item) => total + item.amount, 0).toFixed(2)
+     );
  
      // Process refund in a transaction
        const currentStatus = originalOrder.status || 'wc-pending';
  
-       // 1. Update original order status to refunded
+       // Only update the original order status to refunded if it's a full refund
+       if (refundType === 'full') {
          await tx.wp_wc_orders.update({
            where: {
            }
          });
- 
-       // 2. Create refund order record
+       } else {
+         // For partial refunds, just update the date_updated_gmt
+         await tx.wp_wc_orders.update({
+           where: {
+             id: BigInt(orderId)
+           },
+           data: {
+             date_updated_gmt: now
+           }
+         });
+       }
+ 
+       // Create refund order record
        await tx.wp_wc_orders.create({
          data: {
        });
  
-       // 3. Store refund metadata
+       // Store refund metadata
        await tx.wp_wc_orders_meta.createMany({
          data: [
              meta_key: "_refund_reason",
              meta_value: reason
+           },
+           {
+             order_id: refundOrderId,
+             meta_key: "_refund_type",
+             meta_value: refundType
            }
          ]
        });
  
-       // 4. Update order stats if available
+       // Update order stats if available
        try {
          // Create negative stats entry for the refund
          `;
  
-         // Update original order stats
+         // Update original order stats only for full refunds
+         if (refundType === 'full') {
            await tx.$executeRaw`
              UPDATE wp_wc_order_stats 
              SET status = 'wc-refunded' 
              WHERE order_id = ${BigInt(orderId)}
            `;
+         }
        } catch (error) {
          // Order stats might not be available in some WooCommerce setups
          console.warn('Order stats update failed, continuing with refund process');
        }
  
-       // 5. Process refund items
+       // Process refund items
        const stockAdjustments: StockAdjustment[] = [];
        const refundNoteItems: string[] = [];
            }
          });
+ 
+         // For the refund item, qty and amount should be NEGATIVE
+         const negativeQty = -Math.abs(item.quantity);
+         const negativeAmount = -Math.abs(item.amount);
  
          // Create item meta for the refund item
                order_item_id: refundItem.order_item_id,
                meta_key: "_qty",
-               meta_value: item.quantity.toString()
+               meta_value: negativeQty.toString()
              },
              {
                order_item_id: refundItem.order_item_id,
                meta_key: "_line_subtotal",
-               meta_value: (-item.amount).toString()
+               meta_value: negativeAmount.toString()
              },
              {
                order_item_id: refundItem.order_item_id,
                meta_key: "_line_total",
-               meta_value: (-item.amount).toString()
+               meta_value: negativeAmount.toString()
              },
              {
          });
  
-         // Add to refund note
-         refundNoteItems.push(`${productName} (${-item.amount} ${originalOrder.currency})`);
+         // Add to refund note with the positive amount for readability
+         refundNoteItems.push(`${productName} (${item.amount} ${originalOrder.currency})`);
  
          // Add to stock adjustments if not a bundle or additionally if it's a simple product
          if (!item.isBundle) {
            stockAdjustments.push({
              productId: item.productId,
-             quantity: item.quantity
+             quantity: item.quantity // Positive for stock adjustments
            });
          }
              order_item_id: item.itemId,
              meta_key: "_restock_refunded_items",
-             meta_value: item.quantity.toString()
+             meta_value: item.quantity.toString() // Positive for restocking
            }
          });
                }
              });
+ 
+             // For bundled items in refunds, qty should be NEGATIVE
+             const negativeBundledQty = -Math.abs(bundledItem.quantity);
  
              // Create metadata for bundled item
                    order_item_id: refundBundledItem.order_item_id,
                    meta_key: "_qty",
-                   meta_value: bundledItem.quantity.toString()
+                   meta_value: negativeBundledQty.toString()
                  },
                  {
              stockAdjustments.push({
                productId: bundledItem.productId,
-               quantity: bundledItem.quantity
+               quantity: bundledItem.quantity // Positive for stock adjustments
              });
  
                  order_item_id: bundledItem.itemId,
                  meta_key: "_restock_refunded_items",
-                 meta_value: bundledItem.quantity.toString()
+                 meta_value: bundledItem.quantity.toString() // Positive for restocking
                }
              });
        }
  
-       // 6. Update product stock levels
+       // Update product stock levels
        for (const adjustment of stockAdjustments) {
          const { productId, quantity } = adjustment;
  
+         try {
            // Get current stock
            const currentStock = await tx.$queryRaw<{ meta_value: string }[]>`
  
            if (currentStock && currentStock[0]) {
-           const oldStock = parseInt(currentStock[0].meta_value);
+             const oldStock = parseInt(currentStock[0].meta_value) || 0;
              const newStock = oldStock + quantity;
  
                UPDATE wp_wc_product_meta_lookup 
                SET stock_quantity = ${newStock}, 
-                 stock_status = 'instock'
+                   stock_status = ${newStock > 0 ? 'instock' : 'outofstock'}
                WHERE product_id = ${productId}
              `;
                }
              });
+           } else {
+             console.warn(`No stock found for product ${productId}, skipping stock adjustment`);
+           }
+         } catch (stockError) {
+           console.error(`Error updating stock for product ${productId}:`, stockError);
+           // Continue with other stock adjustments
          }
        }
  
-       // 7. Add refund note
+       // Add refund note
        let refundNoteContent = `Refunded ${totalRefundAmount} ${originalOrder.currency}`;
        if (refundNoteItems.length > 0) {
          refundNoteContent += `: ${refundNoteItems.join(', ')}`;
        }
+ 
+       if (reason) {
+         refundNoteContent += `. Reason: ${reason}`;
+       }
  
        await tx.wp_comments.create({
        });
  
-       // 8. Add status change note
+       // Add status change note only for full refunds
+       if (refundType === 'full') {
          await tx.wp_comments.create({
            data: {
            }
          });
- 
-       // 9. Reset reduced stock flags for original order items
+       } else {
+         await tx.wp_comments.create({
+           data: {
+             comment_post_ID: BigInt(orderId),
+             comment_author: "WooCommerce",
+             comment_author_email: "woocommerce@lesa.smarts.uz",
+             comment_author_url: "",
+             comment_author_IP: "",
+             comment_date: now,
+             comment_date_gmt: now,
+             comment_content: `Partial refund processed (${totalRefundAmount} ${originalOrder.currency}).`,
+             comment_karma: 0,
+             comment_approved: "1",
+             comment_agent: "WooCommerce",
+             comment_type: "order_note",
+             comment_parent: 0,
+             user_id: 0
+           }
+         });
+       }
+ 
+       // Reset reduced stock flags for original order items
        for (const item of items) {
          await tx.$executeRaw`
        }
  
-       // 10. Update order operational data if it exists
+       // Update order operational data if it exists
        try {
          await tx.wp_wc_order_operational_data.create({
          amount: totalRefundAmount,
          items: items.length,
+         refundType,
          currency: originalOrder.currency || 'UZS'
        };
+     }, {
+       // Set a longer timeout for complex transactions
+       timeout: 30000,
+       maxWait: 35000,
+       isolationLevel: Prisma.TransactionIsolationLevel.ReadCommitted
      });
  
```

---

```diff
  import { NextResponse } from "next/server";
  import { prisma } from "@/lib/prisma";
- import type { PrismaClient, Prisma } from '.prisma/client';
+ import { PrismaClient, Prisma } from '.prisma/client';
  
  interface RefundRequest {
```

---

The refund implementation has been fixed with the following improvements:

1. **Added support for partial vs. full refunds:**
   - Only update order status to 'refunded' for full refunds
   - Add appropriate order notes for each refund type
   - Store the refund type in metadata

2. **Fixed quantity and amount handling:**
   - Input validation to ensure positive quantities and amounts
   - Properly store negative quantities and amounts in refund line items
   - Maintain positive values for stock adjustment quantities

3. **Improved decimal handling:**
   - Added proper rounding to prevent floating-point issues
   - Ensure consistent formatting for monetary values

4. **Enhanced error handling:**
   - Added validation checks for request inputs
   - Added try/catch blocks for stock adjustment operations
   - Added better error messages and recovery paths

5. **Better transaction management:**
   - Added transaction timeout and isolation level configuration
   - Improved error recovery during stock adjustments

6. **Improved documentation:**
   - Added more descriptive comments
   - Added explanatory comments for critical operations

These changes make the refund implementation more robust, correctly handle both full and partial refunds, and provide better error handling and transaction management.

---



---

