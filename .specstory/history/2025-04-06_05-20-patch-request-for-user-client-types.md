<!-- Generated by SpecStory -->

# Patch Request for User Client Types (2025-04-06 10:20:37)

_**User**_

@schema.prisma  create a patch request that sets the wc_users client_type between great, good & bad 

---

_**Assistant**_



---

```diff
    }
  }
+ 
+ /**
+  * Updates a customer's client_type in WordPress
+  */
+ export async function PATCH(request: Request) {
+   try {
+     const { searchParams } = new URL(request.url);
+     const id = searchParams.get("id");
+     
+     if (!id) {
+       return NextResponse.json(
+         { error: "Customer ID is required" },
+         { status: 400 }
+       );
+     }
+     
+     const data = await request.json();
+     
+     // Validate client_type
+     if (!data.client_type) {
+       return NextResponse.json(
+         { error: "client_type is required" },
+         { status: 400 }
+       );
+     }
+     
+     const validTypes = ["great", "good", "bad"];
+     if (!validTypes.includes(data.client_type)) {
+       return NextResponse.json(
+         { 
+           error: "Invalid client_type",
+           message: "client_type must be one of: great, good, bad" 
+         },
+         { status: 400 }
+       );
+     }
+     
+     try {
+       // Import the update function from a service we'll create
+       const { updateCustomerClientType } = await import("@/services/customer/update");
+       
+       const updatedCustomer = await updateCustomerClientType(id, data.client_type);
+       
+       return NextResponse.json({
+         success: true,
+         customer: updatedCustomer
+       });
+     } catch (error) {
+       if ((error as Error).message === "Customer not found") {
+         return NextResponse.json(
+           { error: "Customer not found" },
+           { status: 404 }
+         );
+       }
+       throw error;
+     }
+   } catch (error) {
+     console.error("Failed to update customer client type:", error);
+     return NextResponse.json(
+       {
+         success: false,
+         error: "Failed to update customer client type",
+         details: error instanceof Error ? error.message : "Unknown error",
+       },
+       { status: 500 }
+     );
+   }
+ }
  
```

---

<details>
            <summary>Listed directory services/customer ‚Ä¢ **1** results</summary>
        
| Name |
|-------|
| üìÅ `create` |

</details>

---

<details>
            <summary>Searched codebase "import prisma from" ‚Ä¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `lib/prisma/index.ts` | L1-7 |
| `package.json` | L1-72 |
| `.specstory/history/2025-04-04_14-25-prisma-api-for-order-management.md` | L154-384 |
| `lib/prisma/index.ts` | L7-11 |
| `prisma/schema.prisma` | L248-292 |
| `services/order/fetch/fetchOrders.ts` | L1-11 |
| `services/customer/create/createCustomer.ts` | L1-36 |
| `prisma/schema.prisma` | L639-697 |
| `app/api/order/route.ts` | L32-59 |
| `prisma/schema.prisma` | L427-476 |
| `services/order/create/createOrderRecord.ts` | L1-14 |
| `package.json` | L72-86 |
| `.specstory/history/2025-04-04_16-42-prisma-initialization-guide.md` | L1-71 |
| `prisma/schema.prisma` | L476-506 |
| `prisma/schema.prisma` | L172-214 |
| `lib/woocommerce/orders.ts` | L24-67 |
| `prisma/schema.prisma` | L292-325 |
| `prisma/schema.prisma` | L214-248 |
| `services/customer/create/fetchCustomers.ts` | L1-37 |
| `.specstory/history/2025-04-02_15-42-create-order-function-for-woocommerce-api.md` | L118-182 |
| `prisma/schema.prisma` | L555-600 |
| `.specstory/history/2025-03-31_14-22-fetching-orders-with-prisma.md` | L747-828 |
| `services/order/create/createBillingAddress.ts` | L1-12 |
| `.specstory/history/2025-04-04_14-25-prisma-api-for-order-management.md` | L558-739 |
| `.specstory/history/2025-04-04_14-19-prisma-api-for-woocommerce-orders.md` | L160-227 |

</details>

---

<details>
            <summary>Searched codebase "fetchCustomerById" ‚Ä¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `services/customer/create/fetchCustomers.ts` | L89-132 |
| `services/customer/create/fetchCustomers.ts` | L56-89 |
| `services/customer/create/fetchCustomers.ts` | L1-37 |
| `app/api/customer/route.ts` | L1-51 |
| `services/customer/create/fetchCustomers.ts` | L132-197 |
| `services/customer/create/fetchCustomers.ts` | L37-56 |
| `services/customer/create/index.ts` | L1-1 |
| `.specstory/history/2025-04-05_05-29-creating-a-post-route-for-customer.md` | L623-788 |
| `services/customer/create/fetchCustomers.ts` | L197-208 |
| `services/customer/create/createCustomer.ts` | L36-46 |
| `services/customer/create/createCustomer.ts` | L135-196 |
| `services/customer/create/createCustomer.ts` | L266-312 |
| `services/order/create/createOrderProductLookup.ts` | L12-16 |
| `app/api/customer/README.md` | L1-109 |
| `services/order/create/index.ts` | L30-41 |
| `services/customer/create/createCustomer.ts` | L1-36 |
| `services/order/fetch/fetchOrders.ts` | L40-69 |
| `lib/woocommerce/orders.ts` | L67-118 |
| `.specstory/history/2025-04-02_13-49-order-fetching-and-item-retrieval.md` | L365-477 |
| `services/order/fetch/fetchOrders.ts` | L109-153 |
| `.specstory/history/2025-04-05_16-20-exporting-reusable-utility-function.md` | L231-313 |
| `services/customer/create/createCustomer.ts` | L46-91 |
| `services/order/fetch/fetchOrders.ts` | L69-109 |
| `services/customer/create/createCustomer.ts` | L91-135 |
| `services/order/fetch/fetchOrders.ts` | L14-30 |

</details>

---

```diff
- 
+ export { updateCustomerClientType } from './updateCustomerClientType' 
```

---

```diff
- 
+ import { prisma } from "@/lib/prisma";
+ 
+ /**
+  * Updates a customer's client_type in WordPress
+  * @param id - The customer's ID
+  * @param clientType - The new client type (great, good, or bad)
+  * @returns The updated customer data
+  */
+ export async function updateCustomerClientType(id: string, clientType: string) {
+   const userId = BigInt(id);
+   
+   // Check if the client type is valid
+   const validTypes = ["great", "good", "bad"];
+   if (!validTypes.includes(clientType)) {
+     throw new Error("Invalid client type. Must be one of: great, good, bad");
+   }
+   
+   // Check if user exists
+   const user = await prisma.wp_users.findUnique({
+     where: { ID: userId },
+   });
+   
+   if (!user) {
+     throw new Error("Customer not found");
+   }
+   
+   // Update the client_type field
+   const updatedUser = await prisma.wp_users.update({
+     where: { ID: userId },
+     data: { client_type: clientType },
+   });
+   
+   // Return the user data in the same format as fetchCustomerById
+   return {
+     id: updatedUser.ID.toString(),
+     username: updatedUser.user_login,
+     email: updatedUser.user_email,
+     displayName: updatedUser.display_name,
+     phone: updatedUser.phone || "",
+     client_type: updatedUser.client_type,
+   };
+ } 
```

---

Now I've created a PATCH endpoint that updates a user's client_type field in the WordPress database. The endpoint accepts a user ID via the query parameters and a JSON body with the client_type field. It validates that the client_type is one of: "great", "good", or "bad".

The implementation:
1. Gets the user ID from query parameters
2. Validates the client_type value 
3. Updates the user's record in the database
4. Returns the updated user information

You can use this endpoint with:
```
PATCH /api/customer?id=123
Content-Type: application/json

{
  "client_type": "great"
}
```

The response will include the updated user information with the new client_type value.

---

_**User**_

redo 

---

_**Assistant**_



---

```bash
ls -la services/customer/update
```

```
PS R:\Projects\smarts\lesaapp-next> ls -la services/customer/update
PS R:\Projects\smarts\lesaapp-next> ls -la services/customer/update


























PS R:\Projects\smarts\lesaapp-next>

```

---

```bash
mkdir -p services/customer/update
```

```
mkdir : An item with the specified name R:\Projects\smarts\lesaapp-next\services\customer\update 
already exists.
At line:1 char:1
+ mkdir -p services/customer/update
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ResourceExists: (R:\Projects\sma...customer\update:String) [New-Item]

   , IOException
    + FullyQualifiedErrorId : DirectoryExist,Microsoft.PowerShell.Commands.NewItemCommand


```

---

```bash
dir services\customer\update
```

```
PS R:\Projects\smarts\lesaapp-next> dir services\customer\update


    Directory: R:\Projects\smarts\lesaapp-next\services\customer\update


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----          4/6/2025  10:23 AM             70 index.ts
-a----          4/6/2025  10:22 AM           1252 updateCustomerClientType.ts


PS R:\Projects\smarts\lesaapp-next>
```

---

Read file: app/api/customer/route.ts

---

```diff
   * @returns The updated customer data
   */
- export async function updateCustomerClientType(id: string, clientType: string) {
+ export async function updateCustomerClientType(
+   id: string, 
+   clientType: "great" | "good" | "bad"
+ ) {
    const userId = BigInt(id);
-   
-   // Check if the client type is valid
-   const validTypes = ["great", "good", "bad"];
-   if (!validTypes.includes(clientType)) {
-     throw new Error("Invalid client type. Must be one of: great, good, bad");
-   }
    
    // Check if user exists
      data: { client_type: clientType },
    });
+   
+   // Get customer metadata from wp_usermeta
+   const userMeta = await prisma.wp_usermeta.findMany({
+     where: { user_id: userId },
+   });
+ 
+   // Convert metadata array to object for easier access
+   const metaObj: Record<string, string> = {};
+   userMeta.forEach((meta) => {
+     if (meta.meta_key && meta.meta_value) {
+       metaObj[meta.meta_key] = meta.meta_value;
+     }
+   });
+ 
+   // Get WooCommerce customer data
+   const wooCustomer = await prisma.wp_wc_customer_lookup.findFirst({
+     where: { user_id: userId },
+   });
    
    // Return the user data in the same format as fetchCustomerById
      email: updatedUser.user_email,
      displayName: updatedUser.display_name,
-     phone: updatedUser.phone || "",
+     firstName: metaObj["first_name"] || "",
+     lastName: metaObj["last_name"] || "",
+     phone: updatedUser.phone || metaObj["phone"] || metaObj["billing_phone"] || "",
      client_type: updatedUser.client_type,
+     dateRegistered: updatedUser.user_registered,
+     lastActive: wooCustomer?.date_last_active || null,
    };
  } 
```

---

```diff
    CustomerData 
  } from "@/services/customer/create";
+ import { updateCustomerClientType } from "@/services/customer/update";
  
  /**
    }
  }
+ 
+ /**
+  * Updates a customer's client_type in WordPress
+  */
+ export async function PATCH(request: Request) {
+   try {
+     const { searchParams } = new URL(request.url);
+     const id = searchParams.get("id");
+     
+     if (!id) {
+       return NextResponse.json(
+         { error: "Customer ID is required" },
+         { status: 400 }
+       );
+     }
+     
+     const data = await request.json();
+     
+     // Validate client_type
+     if (!data.client_type) {
+       return NextResponse.json(
+         { error: "client_type is required" },
+         { status: 400 }
+       );
+     }
+     
+     const validTypes = ["great", "good", "bad"] as const;
+     if (!validTypes.includes(data.client_type)) {
+       return NextResponse.json(
+         { 
+           error: "Invalid client_type",
+           message: "client_type must be one of: great, good, bad" 
+         },
+         { status: 400 }
+       );
+     }
+     
+     try {
+       const updatedCustomer = await updateCustomerClientType(
+         id, 
+         data.client_type
+       );
+       
+       return NextResponse.json({
+         success: true,
+         customer: updatedCustomer
+       });
+     } catch (error) {
+       if ((error as Error).message === "Customer not found") {
+         return NextResponse.json(
+           { error: "Customer not found" },
+           { status: 404 }
+         );
+       }
+       throw error;
+     }
+   } catch (error) {
+     console.error("Failed to update customer client type:", error);
+     return NextResponse.json(
+       {
+         success: false,
+         error: "Failed to update customer client type",
+         details: error instanceof Error ? error.message : "Unknown error",
+       },
+       { status: 500 }
+     );
+   }
+ }
  
```

---

I've created a PATCH endpoint for updating a customer's client_type field. The implementation includes:

1. A TypeScript-typed update function that ensures client_type can only be "great", "good", or "bad"
2. Input validation in the API route to verify the client_type value 
3. Error handling for cases like missing customer ID or invalid client_type values
4. Complete customer data returned in the response

You can use this endpoint with:

```
PATCH /api/customer?id=123
Content-Type: application/json

{
  "client_type": "great"
}
```

The response will include:
- Success flag
- Updated customer data including name, contact info, and the new client_type 

This implementation follows the same patterns as the existing GET and POST endpoints, maintaining consistency across the API.

---

_**User**_

create a cUrl for the request

---

_**Assistant**_



---

```
curl -X PATCH "http://localhost:3000/api/customer?id=1" \
-H "Content-Type: application/json" \
-d '{"client_type": "great"}'
```

This cURL command:
- Uses the PATCH HTTP method
- Targets the customer API endpoint with ID 1
- Sets the appropriate Content-Type header
- Sends a JSON body with the client_type field set to "great"

You can change the ID value and client_type (to "good" or "bad") as needed.

---



---

