<!-- Generated by SpecStory -->

# Database Migration for WooCommerce Orders (2025-04-06 10:16:51)

_**User**_

insert them like refund order to wp_wc_order_product_lookup to wp_wc_order_lost_product. you know databse structure @schema.prisma . write API route for this to @route.ts 

---

_**Assistant**_

I'll help you create a route.ts file that inserts order product data from wp_wc_order_product_lookup to wp_wc_order_lost_product. Based on the schema in prisma/schema.prisma, I can see both tables have similar structures, with wp_wc_order_lost_product having a few additional fields for regular_price and sale_price.

Let me create the API route:

---

Read file: app/api/complete-order/route.ts

---

Now, I'll create the API route that will handle transferring order product data from wp_wc_order_product_lookup to wp_wc_order_lost_product:

---

```diff
- 
+ import { PrismaClient } from '@prisma/client'
+ import { NextRequest, NextResponse } from 'next/server'
+ 
+ const prisma = new PrismaClient()
+ 
+ export async function POST(request: NextRequest) {
+   try {
+     const { orderId } = await request.json()
+ 
+     if (!orderId) {
+       return NextResponse.json(
+         { error: 'Order ID is required' },
+         { status: 400 }
+       )
+     }
+ 
+     // Get parent order ID and child orders IDs
+     const order = await prisma.wp_wc_orders.findUnique({
+       where: {
+         id: BigInt(orderId)
+       },
+       select: {
+         id: true
+       }
+     })
+ 
+     if (!order) {
+       return NextResponse.json(
+         { error: 'Order not found' },
+         { status: 404 }
+       )
+     }
+ 
+     // Get all child orders
+     const childOrders = await prisma.wp_wc_orders.findMany({
+       where: {
+         parent_order_id: BigInt(orderId)
+       },
+       select: {
+         id: true
+       }
+     })
+ 
+     // Combine parent and child order IDs
+     const allOrderIds = [order.id, ...childOrders.map(order => order.id)]
+ 
+     // Get all products from these orders
+     const orderProducts = await prisma.wp_wc_order_product_lookup.findMany({
+       where: {
+         order_id: {
+           in: allOrderIds
+         }
+       }
+     })
+ 
+     if (orderProducts.length === 0) {
+       return NextResponse.json(
+         { message: 'No products found for this order' },
+         { status: 200 }
+       )
+     }
+ 
+     // Get product prices for the additional fields
+     const productIds = [...new Set(orderProducts.map(product => product.product_id))]
+     const productPrices = await prisma.wp_wc_product_meta_lookup.findMany({
+       where: {
+         product_id: {
+           in: productIds
+         }
+       },
+       select: {
+         product_id: true,
+         min_price: true,
+         max_price: true
+       }
+     })
+ 
+     // Create a map of product prices
+     const priceMap = new Map()
+     productPrices.forEach(product => {
+       priceMap.set(Number(product.product_id), {
+         regular_price: product.max_price ? BigInt(product.max_price.toString().replace('.', '')) : null,
+         sale_price: product.min_price ? BigInt(product.min_price.toString().replace('.', '')) : null
+       })
+     })
+ 
+     // Prepare data for insertion into wp_wc_order_lost_product
+     const lostProductsData = orderProducts.map(product => {
+       const prices = priceMap.get(Number(product.product_id)) || { regular_price: null, sale_price: null }
+       
+       return {
+         order_item_id: product.order_item_id,
+         order_id: product.order_id,
+         product_id: product.product_id,
+         variation_id: product.variation_id,
+         customer_id: product.customer_id,
+         date_created: product.date_created,
+         product_qty: product.product_qty,
+         product_net_revenue: product.product_net_revenue,
+         product_gross_revenue: product.product_gross_revenue,
+         coupon_amount: product.coupon_amount,
+         tax_amount: product.tax_amount,
+         shipping_amount: product.shipping_amount,
+         shipping_tax_amount: product.shipping_tax_amount,
+         rental_price: product.rental_price,
+         used_days: product.used_days,
+         regular_price: prices.regular_price,
+         sale_price: prices.sale_price
+       }
+     })
+ 
+     // Check if records already exist in the lost products table
+     const existingLostProducts = await prisma.wp_wc_order_lost_product.findMany({
+       where: {
+         order_item_id: {
+           in: lostProductsData.map(product => product.order_item_id)
+         }
+       },
+       select: {
+         order_item_id: true
+       }
+     })
+ 
+     const existingOrderItemIds = new Set(existingLostProducts.map(product => Number(product.order_item_id)))
+     
+     // Filter out products that already exist in the lost products table
+     const newLostProducts = lostProductsData.filter(
+       product => !existingOrderItemIds.has(Number(product.order_item_id))
+     )
+ 
+     if (newLostProducts.length === 0) {
+       return NextResponse.json(
+         { message: 'All products already exist in the lost products table' },
+         { status: 200 }
+       )
+     }
+ 
+     // Insert data into wp_wc_order_lost_product
+     const result = await prisma.wp_wc_order_lost_product.createMany({
+       data: newLostProducts,
+       skipDuplicates: true
+     })
+ 
+     // Mark order as completed if needed
+     await prisma.wp_wc_orders.update({
+       where: {
+         id: BigInt(orderId)
+       },
+       data: {
+         is_completed: true
+       }
+     })
+ 
+     return NextResponse.json({
+       success: true,
+       message: `Successfully transferred ${result.count} products to lost products table`,
+       totalProducts: orderProducts.length,
+       transferredProducts: result.count
+     })
+   } catch (error) {
+     console.error('Error completing order:', error)
+     return NextResponse.json(
+       { error: 'Failed to complete order', details: error.message },
+       { status: 500 }
+     )
+   }
+ }
+ 
```

---

I need to fix the linter error related to the unknown error type. Let's update the code:

---

```diff
        transferredProducts: result.count
      })
-   } catch (error) {
+   } catch (error: any) {
      console.error('Error completing order:', error)
      return NextResponse.json(
-       { error: 'Failed to complete order', details: error.message },
+       { error: 'Failed to complete order', details: error.message || String(error) },
        { status: 500 }
      )
```

---

Great! I've created a robust API route for transferring product records from `wp_wc_order_product_lookup` to `wp_wc_order_lost_product` and fixed the linter error.

Here's a summary of what the API does:

1. **Accepts a POST request** with an `orderId` in the request body.
2. **Validates the input** and checks if the order exists.
3. **Gets all relevant orders**: both the parent order and any child orders.
4. **Retrieves all products** from the `wp_wc_order_product_lookup` table associated with these orders.
5. **Gets product pricing information** from `wp_wc_product_meta_lookup` for the additional fields required in the lost products table.
6. **Prepares data for insertion** into the `wp_wc_order_lost_product` table, mapping all fields from the source table and adding the additional regular_price and sale_price fields.
7. **Checks for existing records** in the lost products table to avoid duplicates.
8. **Inserts only new records** with the `createMany` operation and `skipDuplicates` option.
9. **Updates the order** as completed by setting `is_completed` to true.
10. **Returns a response** with information about the operation results.
11. **Handles errors** properly with meaningful error messages.

The API handles BigInt values correctly for database IDs, which is important when working with WordPress tables that often use unsigned bigint IDs. It also includes proper error handling and provides detailed response information.

To use this API, you would make a POST request to `/api/complete-order` with a JSON body like:
```json
{
  "orderId": 123456
}
```

The response will include information about how many products were transferred and the total number of products found.

---

_**User**_

don't write anything to regular price and sale price

---

_**Assistant**_

I'll modify the code to remove the regular_price and sale_price assignments. Let me update the API route:

---

```diff
        )
      }
- 
-     // Get product prices for the additional fields
-     const productIds = [...new Set(orderProducts.map(product => product.product_id))]
-     const productPrices = await prisma.wp_wc_product_meta_lookup.findMany({
-       where: {
-         product_id: {
-           in: productIds
-         }
-       },
-       select: {
-         product_id: true,
-         min_price: true,
-         max_price: true
-       }
-     })
- 
-     // Create a map of product prices
-     const priceMap = new Map()
-     productPrices.forEach(product => {
-       priceMap.set(Number(product.product_id), {
-         regular_price: product.max_price ? BigInt(product.max_price.toString().replace('.', '')) : null,
-         sale_price: product.min_price ? BigInt(product.min_price.toString().replace('.', '')) : null
-       })
-     })
  
      // Prepare data for insertion into wp_wc_order_lost_product
      const lostProductsData = orderProducts.map(product => {
-       const prices = priceMap.get(Number(product.product_id)) || { regular_price: null, sale_price: null }
-       
        return {
          order_item_id: product.order_item_id,
          shipping_tax_amount: product.shipping_tax_amount,
          rental_price: product.rental_price,
-         used_days: product.used_days,
-         regular_price: prices.regular_price,
-         sale_price: prices.sale_price
+         used_days: product.used_days
+         // regular_price and sale_price not included as requested
        }
      })
```

---

Now I've updated the API route as requested. Here's what changed:

1. Removed the code that fetches product prices from `wp_wc_product_meta_lookup`
2. Removed the price mapping code that was previously used to set the `regular_price` and `sale_price` fields
3. Removed those fields from the data being inserted into the `wp_wc_order_lost_product` table
4. Added a comment indicating that these fields are intentionally not included as requested

The updated API route will now only copy the fields that are directly available in the `wp_wc_order_product_lookup` table to the `wp_wc_order_lost_product` table, without attempting to set values for the `regular_price` and `sale_price` fields.

This will leave those fields as NULL in the database, which appears to be your desired behavior based on your request to "don't write anything to regular price and sale price".

The rest of the functionality remains the same - the API will still:
- Find the parent and child orders
- Get all products from these orders
- Check for existing records to avoid duplicates
- Insert only new records
- Mark the order as completed
- Return information about the operation

---

_**User**_

wp_wc_order_product_lookup dagi @example.sql ga mos tushadiganini qaytarilmaganlarini yozib qoyishing kerak. musbat sonlarni manfiy sonlarga qoshib yuborib agar 0 ga teng bolmasa lost_productga yozishi kerak @schema.prisma 

---

_**Assistant**_

I'll analyze your request. You want to use the SQL example from `example.sql` to filter the orders and calculate something with the product quantities (converting positive numbers to negative and checking if they sum to zero).

Let me check the example SQL file first:

---

Read file: app/api/complete-order/example.sql

---

Based on the SQL example and your request, I understand that:

1. You need to get all order IDs where parent_order_id matches the input ID
2. Get all product IDs from these orders
3. Calculate the sum of quantities for each product 
4. If the sum is not zero (meaning some products weren't returned), add those to the lost products table

Let me update the route.ts file to implement this logic:

---

```diff
      }
  
-     // Get parent order ID and child orders IDs
-     const order = await prisma.wp_wc_orders.findUnique({
-       where: {
-         id: BigInt(orderId)
-       },
-       select: {
-         id: true
-       }
-     })
- 
-     if (!order) {
-       return NextResponse.json(
-         { error: 'Order not found' },
-         { status: 404 }
-       )
-     }
- 
-     // Get all child orders
+     // Get all child orders as in example.sql
      const childOrders = await prisma.wp_wc_orders.findMany({
        where: {
      })
  
-     // Combine parent and child order IDs
-     const allOrderIds = [order.id, ...childOrders.map(order => order.id)]
+     if (childOrders.length === 0) {
+       return NextResponse.json(
+         { message: 'No child orders found for this order' },
+         { status: 200 }
+       )
+     }
+ 
+     // Get all order IDs (child orders)
+     const orderIds = childOrders.map(order => order.id)
  
      // Get all products from these orders
-     const orderProducts = await prisma.wp_wc_order_product_lookup.findMany({
+     const allOrderProducts = await prisma.wp_wc_order_product_lookup.findMany({
        where: {
          order_id: {
-           in: allOrderIds
+           in: orderIds
          }
        }
      })
  
-     if (orderProducts.length === 0) {
+     if (allOrderProducts.length === 0) {
        return NextResponse.json(
-         { message: 'No products found for this order' },
+         { message: 'No products found for these orders' },
          { status: 200 }
        )
      }
  
-     // Prepare data for insertion into wp_wc_order_lost_product
-     const lostProductsData = orderProducts.map(product => {
-       return {
-         order_item_id: product.order_item_id,
-         order_id: product.order_id,
-         product_id: product.product_id,
-         variation_id: product.variation_id,
-         customer_id: product.customer_id,
-         date_created: product.date_created,
-         product_qty: product.product_qty,
-         product_net_revenue: product.product_net_revenue,
-         product_gross_revenue: product.product_gross_revenue,
-         coupon_amount: product.coupon_amount,
-         tax_amount: product.tax_amount,
-         shipping_amount: product.shipping_amount,
-         shipping_tax_amount: product.shipping_tax_amount,
-         rental_price: product.rental_price,
-         used_days: product.used_days
-         // regular_price and sale_price not included as requested
-       }
-     })
+     // Get unique product IDs from all orders
+     const productIds = [...new Set(allOrderProducts.map(product => product.product_id))]
+ 
+     // Group products by product_id and calculate sum of quantities
+     const productQuantitySums = new Map()
+     
+     for (const product of allOrderProducts) {
+       const productId = Number(product.product_id)
+       const currentSum = productQuantitySums.get(productId) || 0
+       
+       // Add the quantity - convert positive to negative by adding product_qty (which is already negative for returns)
+       productQuantitySums.set(productId, currentSum + product.product_qty)
+     }
+ 
+     // Filter products that have non-zero sum (meaning they weren't fully returned)
+     const lostProductsData = []
+     
+     for (const [productId, quantitySum] of productQuantitySums.entries()) {
+       if (quantitySum !== 0) {
+         // Find all order products for this product ID
+         const productsForThisId = allOrderProducts.filter(
+           product => Number(product.product_id) === productId
+         )
+         
+         // Take the first occurrence of this product (original order)
+         // We'll use this as our record for the lost product
+         const originalProduct = productsForThisId[0]
+         
+         lostProductsData.push({
+           order_item_id: originalProduct.order_item_id,
+           order_id: originalProduct.order_id,
+           product_id: originalProduct.product_id,
+           variation_id: originalProduct.variation_id,
+           customer_id: originalProduct.customer_id,
+           date_created: originalProduct.date_created,
+           product_qty: Math.abs(quantitySum), // Use absolute value of the sum as the quantity
+           product_net_revenue: originalProduct.product_net_revenue,
+           product_gross_revenue: originalProduct.product_gross_revenue,
+           coupon_amount: originalProduct.coupon_amount,
+           tax_amount: originalProduct.tax_amount,
+           shipping_amount: originalProduct.shipping_amount,
+           shipping_tax_amount: originalProduct.shipping_tax_amount,
+           rental_price: originalProduct.rental_price,
+           used_days: originalProduct.used_days
+         })
+       }
+     }
+ 
+     if (lostProductsData.length === 0) {
+       return NextResponse.json(
+         { message: 'All products were returned (sum of quantities is zero)' },
+         { status: 200 }
+       )
+     }
  
      // Check if records already exist in the lost products table
      if (newLostProducts.length === 0) {
        return NextResponse.json(
-         { message: 'All products already exist in the lost products table' },
+         { message: 'All lost products already exist in the lost products table' },
          { status: 200 }
        )
      })
  
-     // Mark order as completed if needed
+     // Mark order as completed
      await prisma.wp_wc_orders.update({
        where: {
      return NextResponse.json({
        success: true,
-       message: `Successfully transferred ${result.count} products to lost products table`,
-       totalProducts: orderProducts.length,
+       message: `Successfully transferred ${result.count} lost products to lost products table`,
+       totalLostProducts: lostProductsData.length,
        transferredProducts: result.count
      })
```

---

I've updated the API route to implement the logic according to your requirements and the example SQL file. Here's what the updated code does:

1. **Gets all child orders** for the provided parent order ID
2. **Retrieves all products** from these child orders 
3. **Calculates the sum of quantities** for each unique product ID across all child orders
4. **Identifies lost products** by checking if the sum of quantities is not zero (some products weren't returned)
5. **Creates records for the lost products** using data from the original order, with the quantity set to the absolute value of the sum (representing the actual lost quantity)
6. **Avoids duplicates** by checking if records already exist in the lost products table
7. **Marks the parent order as completed** after transferring the lost products

Key changes:

1. Now we only look at child orders (not parent order products)
2. We aggregate quantities by product_id to determine if products were fully returned
3. We only insert records for products with non-zero quantity sums
4. The quantity used is the absolute value of the sum, representing how many were lost

This implementation follows the concept in your example SQL:
- Get all orders related to the parent order
- Get all product IDs from these orders
- Sum the quantities for each product
- If the sum isn't zero, it means some products weren't returned and should be recorded as lost

The response includes information about how many lost products were found and how many were successfully transferred to the lost products table.

---



---

