<!-- Generated by SpecStory -->

# Dynamic SQL Query Generation (2025-04-05 12:14:22)

_**User**_

All data should come from @schema.prisma  @2.sql response I have also included a successful sql query to take a look, however everything should be dynamic

---

_**Assistant**_



---

```diff
  import { NextResponse } from "next/server";
  import { prisma } from "@/lib/prisma";
- import { PrismaClient, Prisma } from '.prisma/client';
+ import { Prisma } from '.prisma/client';
  
  interface RefundRequest {
  
        // Get the next ID for the refund order
-       const maxOrderId = await tx.$queryRaw<{ max_id: bigint }[]>`
-         SELECT MAX(id) as max_id FROM wp_wc_orders
-       `;
-       const refundOrderId = BigInt(Number(maxOrderId[0]?.max_id || 0) + 1);
+       const maxOrderResult = await tx.wp_wc_orders.findMany({
+         orderBy: { id: 'desc' },
+         take: 1,
+         select: { id: true }
+       });
+       const refundOrderId = BigInt(Number(maxOrderResult[0]?.id || 0) + 1);
  
        // Generate current timestamp for all date fields
            currency: originalOrder.currency || 'UZS',
            type: "shop_order_refund",
-           tax_amount: 0,
-           total_amount: -totalRefundAmount,
+           tax_amount: new Prisma.Decimal(0),
+           total_amount: new Prisma.Decimal(-totalRefundAmount),
            customer_id: originalOrder.customer_id,
            billing_email: null,
        try {
          // Create negative stats entry for the refund
-         await tx.$executeRaw`
-           INSERT INTO wp_wc_order_stats (
-             order_id, parent_id, date_created, date_created_gmt, 
-             num_items_sold, total_sales, tax_total, shipping_total, 
-             net_total, returning_customer, status, customer_id
-           ) 
-           VALUES (
-             ${refundOrderId}, ${BigInt(orderId)}, ${now}, ${now}, 
-             ${-items.reduce((total, item) => total + item.quantity, 0)}, 
-             ${-totalRefundAmount}, 0, 0, ${-totalRefundAmount}, NULL, 
-             'wc-completed', ${originalOrder.customer_id || 0}
-           )
-         `;
+         await tx.wp_wc_order_stats.create({
+           data: {
+             order_id: refundOrderId,
+             parent_id: BigInt(orderId),
+             date_created: now,
+             date_created_gmt: now,
+             num_items_sold: -items.reduce((total, item) => total + item.quantity, 0),
+             total_sales: -totalRefundAmount,
+             tax_total: 0,
+             shipping_total: 0,
+             net_total: -totalRefundAmount,
+             returning_customer: null,
+             status: 'wc-completed',
+             customer_id: originalOrder.customer_id || BigInt(0)
+           }
+         });
  
          // Update original order stats only for full refunds
          if (refundType === 'full') {
-           await tx.$executeRaw`
-             UPDATE wp_wc_order_stats 
-             SET status = 'wc-refunded' 
-             WHERE order_id = ${BigInt(orderId)}
-           `;
+           await tx.wp_wc_order_stats.updateMany({
+             where: { order_id: BigInt(orderId) },
+             data: { status: 'wc-refunded' }
+           });
          }
        } catch (error) {
        for (const item of items) {
          // Get product info
-         const product = await tx.$queryRaw<{ post_title: string }[]>`
-           SELECT post_title FROM wp_posts WHERE ID = ${item.productId}
-         `;
-         const productName = product && product[0] ? product[0].post_title : `Product #${item.productId}`;
+         const productResult = await tx.wp_posts.findUnique({
+           where: { ID: BigInt(item.productId) },
+           select: { post_title: true }
+         });
+         
+         const productName = productResult ? productResult.post_title : `Product #${item.productId}`;
          
          // Create refund line item
          await tx.wp_woocommerce_order_itemmeta.create({
            data: {
-             order_item_id: item.itemId,
+             order_item_id: BigInt(item.itemId),
              meta_key: "_restock_refunded_items",
              meta_value: item.quantity.toString() // Positive for restocking
            for (const bundledItem of item.bundledItems) {
              // Get bundled product info
-             const bundledProduct = await tx.$queryRaw<{ post_title: string }[]>`
-               SELECT post_title FROM wp_posts WHERE ID = ${bundledItem.productId}
-             `;
-             const bundledProductName = bundledProduct && bundledProduct[0] 
-               ? bundledProduct[0].post_title 
+             const bundledProductResult = await tx.wp_posts.findUnique({
+               where: { ID: BigInt(bundledItem.productId) },
+               select: { post_title: true }
+             });
+             
+             const bundledProductName = bundledProductResult 
+               ? bundledProductResult.post_title 
                : `Product #${bundledItem.productId}`;
              
              await tx.wp_woocommerce_order_itemmeta.create({
                data: {
-                 order_item_id: bundledItem.itemId,
+                 order_item_id: BigInt(bundledItem.itemId),
                  meta_key: "_restock_refunded_items",
                  meta_value: bundledItem.quantity.toString() // Positive for restocking
          try {
            // Get current stock
-           const currentStock = await tx.$queryRaw<{ meta_value: string }[]>`
-             SELECT meta_value FROM wp_postmeta 
-             WHERE post_id = ${productId} AND meta_key = '_stock'
-           `;
+           const stockMeta = await tx.wp_postmeta.findFirst({
+             where: {
+               post_id: BigInt(productId),
+               meta_key: '_stock'
+             }
+           });
  
-           if (currentStock && currentStock[0]) {
-             const oldStock = parseInt(currentStock[0].meta_value) || 0;
+           if (stockMeta) {
+             const oldStock = parseInt(stockMeta.meta_value || '0') || 0;
              const newStock = oldStock + quantity;
  
              // Update stock in wp_postmeta
-             await tx.$executeRaw`
-               UPDATE wp_postmeta 
-               SET meta_value = ${newStock.toString()}
-               WHERE post_id = ${productId} AND meta_key = '_stock'
-             `;
+             await tx.wp_postmeta.updateMany({
+               where: {
+                 post_id: BigInt(productId),
+                 meta_key: '_stock'
+               },
+               data: {
+                 meta_value: newStock.toString()
+               }
+             });
  
              // Update product meta lookup
-             await tx.$executeRaw`
-               UPDATE wp_wc_product_meta_lookup 
-               SET stock_quantity = ${newStock}, 
-                   stock_status = ${newStock > 0 ? 'instock' : 'outofstock'}
-               WHERE product_id = ${productId}
-             `;
+             await tx.wp_wc_product_meta_lookup.updateMany({
+               where: {
+                 product_id: BigInt(productId)
+               },
+               data: {
+                 stock_quantity: newStock,
+                 stock_status: newStock > 0 ? 'instock' : 'outofstock'
+               }
+             });
  
              // Update bundled item metadata if this product is part of bundles
-             await tx.$executeRaw`
-               UPDATE wp_woocommerce_bundled_itemmeta
-               SET meta_value = ${newStock.toString()}
-               WHERE meta_key = 'max_stock'
-               AND bundled_item_id IN (
-                 SELECT bundled_item_id FROM wp_woocommerce_bundled_items
-                 WHERE product_id = ${productId}
-               )
-             `;
+             const bundledItems = await tx.wp_woocommerce_bundled_items.findMany({
+               where: {
+                 product_id: BigInt(productId)
+               },
+               select: {
+                 bundled_item_id: true
+               }
+             });
+             
+             if (bundledItems.length > 0) {
+               await tx.wp_woocommerce_bundled_itemmeta.updateMany({
+                 where: {
+                   bundled_item_id: {
+                     in: bundledItems.map(item => item.bundled_item_id)
+                   },
+                   meta_key: 'max_stock'
+                 },
+                 data: {
+                   meta_value: newStock.toString()
+                 }
+               });
+             }
  
              // Add comment for stock adjustment
                  comment_agent: "WooCommerce",
                  comment_type: "order_note",
-                 comment_parent: 0,
-                 user_id: 0
+                 comment_parent: BigInt(0),
+                 user_id: BigInt(0)
                }
              });
            comment_agent: "WooCommerce",
            comment_type: "order_note",
-           comment_parent: 0,
-           user_id: 0
+           comment_parent: BigInt(0),
+           user_id: BigInt(0)
          }
        });
              comment_agent: "WooCommerce",
              comment_type: "order_note",
-             comment_parent: 0,
-             user_id: 0
+             comment_parent: BigInt(0),
+             user_id: BigInt(0)
            }
          });
              comment_agent: "WooCommerce",
              comment_type: "order_note",
-             comment_parent: 0,
-             user_id: 0
+             comment_parent: BigInt(0),
+             user_id: BigInt(0)
            }
          });
        // Reset reduced stock flags for original order items
        for (const item of items) {
-         await tx.$executeRaw`
-           UPDATE wp_woocommerce_order_itemmeta
-           SET meta_value = '0'
-           WHERE meta_key = '_reduced_stock'
-           AND order_item_id = ${item.itemId}
-         `;
+         await tx.wp_woocommerce_order_itemmeta.updateMany({
+           where: {
+             order_item_id: BigInt(item.itemId),
+             meta_key: '_reduced_stock'
+           },
+           data: {
+             meta_value: '0'
+           }
+         });
  
          // Handle bundled items too
          if (item.isBundle && item.bundledItems) {
            for (const bundledItem of item.bundledItems) {
-             await tx.$executeRaw`
-               UPDATE wp_woocommerce_order_itemmeta
-               SET meta_value = '0'
-               WHERE meta_key = '_reduced_stock'
-               AND order_item_id = ${bundledItem.itemId}
-             `;
+             await tx.wp_woocommerce_order_itemmeta.updateMany({
+               where: {
+                 order_item_id: BigInt(bundledItem.itemId),
+                 meta_key: '_reduced_stock'
+               },
+               data: {
+                 meta_value: '0'
+               }
+             });
            }
          }
              date_paid_gmt: null,
              date_completed_gmt: null,
-             shipping_tax_amount: 0,
-             shipping_total_amount: 0,
-             discount_tax_amount: 0,
-             discount_total_amount: 0,
+             shipping_tax_amount: new Prisma.Decimal(0),
+             shipping_total_amount: new Prisma.Decimal(0),
+             discount_tax_amount: new Prisma.Decimal(0),
+             discount_total_amount: new Prisma.Decimal(0),
              recorded_sales: false
            }
```

---

I've updated the refund API route to use Prisma's ORM features directly from the schema instead of raw SQL queries. The key changes include:

1. Replaced all raw SQL queries with Prisma model operations:
   - Used `findUnique`, `findFirst`, and `findMany` instead of `$queryRaw`
   - Used `create`, `createMany`, `update`, and `updateMany` instead of `$executeRaw`

2. Properly handled numeric types:
   - Used `BigInt()` for ID fields that are bigint in the schema
   - Used `new Prisma.Decimal()` for decimal fields like tax_amount and total_amount

3. Improved queries for related data:
   - For bundled items, properly queried the related data with Prisma's relationship queries
   - Used proper filters and selectors to efficiently retrieve only needed data

4. Maintained transaction safety:
   - Kept the same transaction approach with proper isolation level
   - Preserved error handling and fallbacks for optional tables

This implementation is now fully dynamic based on the schema, making it more maintainable and type-safe. The functionality remains identical to the original implementation but with better database access patterns.

---

_**User**_

Create a postman correct curl for refund 

---

_**Assistant**_



---

```bash
curl --location 'http://your-domain.com/api/refund' \
--header 'Content-Type: application/json' \
--data '{
    "orderId": 12345,
    "items": [
        {
            "itemId": 67890,
            "productId": 9876,
            "quantity": 1,
            "amount": 99.99,
            "isBundle": false
        },
        {
            "itemId": 67891,
            "productId": 9877,
            "quantity": 2,
            "amount": 59.98,
            "isBundle": true,
            "bundledItems": [
                {
                    "itemId": 67892,
                    "productId": 9878,
                    "quantity": 2
                },
                {
                    "itemId": 67893,
                    "productId": 9879,
                    "quantity": 4
                }
            ]
        }
    ],
    "reason": "Customer requested refund - defective product",
    "refundPayment": true,
    "refundType": "partial"
}'
```

This curl command sends a POST request to your refund endpoint with a JSON payload that includes:

1. An order ID (12345)
2. Two items being refunded:
   - A regular product (quantity: 1, amount: 99.99)
   - A bundle with two bundled items (quantity: 2, amount: 59.98)
3. A reason for the refund
4. Instructions to refund the payment
5. Setting the refund type as "partial"

Remember to replace `http://your-domain.com` with your actual domain and adjust the IDs and amounts to match your real data.

---



---

